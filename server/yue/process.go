package yue

import (
	"log"
	"sync"

	proto "./proto"
)

//ExecuterFactory represents object can create Executer object
type ExecuterFactory interface {
	Create(uint64, ...interface{}) (Executer, error)
	Destroy(Executer)
}

//represents common rpc executer interface. 
type Executer interface {
	Call(string, ...interface{}) (interface {}, error)
}

//represent spawn configuration
type SpawnConfig struct {
	Factory ExecuterFactory
	args []interface{}
}



//represents process id. 
//it is generated by Node.NewUUID. you can resolve which node has this actor via nodes database of cockroachdb.
//ofcource, node may be restart and actually no actor exists on it, in that case, this node's seed is greater than
//timestamp part of processid, so caller node can return error.
type ProcessId proto.ProcessId

//represents process (worker of each actor)
type Process struct {
	Id proto.ProcessId
	Executer Executer
	conf *SpawnConfig
	owner *actor
}

//create new process instance
func newprocess(owner *actor, conf *SpawnConfig) (*Process, error) {
	p := &Process {
		Id: proto.ProcessId(NewId()),
		conf: conf,
		owner: owner,
	}
	if err := p.start(); err != nil {
		return nil, err
	}
	return p, nil
}

//Call pass RPC argument to executer, restart if panic level error happen
//TODO: should we need the single thread mode? for example, prepare queue and every call() processed by single goroutine.
func (p *Process) call(method string, args ...interface{}) (r interface{}, err error, rs bool) {
	defer func() {
        if err := recover(); err != nil {
            log.Println("call executer panics:", err)
            amgr().restartq <- p
            r = nil
            rs = true
        }
    }()
	if p.Executer == nil {
		rs = true
		return
	}
    r, err = p.Executer.Call(method, args...)
    rs = false
    return
}

//common process control
func (p *Process) control(stop bool) (err error) {
	defer func() {
        if e := recover(); e != nil {
            log.Println("create executer panics:", e)
            p.Executer = nil
            err = e.(error)
        }
    }()
	if p.Executer != nil {
		p.conf.Factory.Destroy(p.Executer)
		p.Executer = nil
	}
	if !stop {
		p.Executer, err = p.conf.Factory.Create(uint64(p.Id), p.conf.args...)
	}
	return
}

//start process
func (p *Process) start() error {
	return p.control(false)
}

//stop process
func (p *Process) stop() error {
	return p.control(true)
}



//processmgr represents processes which runs in this node
type processmgr struct {
	processes map[proto.ProcessId]*Process
	pmtx sync.RWMutex
}

func newprocessmgr() *processmgr {
	return &processmgr {
		processes: make(map[proto.ProcessId]*Process),
		pmtx: sync.RWMutex{},
	}
}

//spawn creates process by using given factory
func (pm *processmgr) spawn(owner *actor, conf *SpawnConfig) (*Process, error) {
    p, err := newprocess(owner, conf)
    if err != nil {
    	return nil, err
    }
	defer pm.pmtx.Unlock()
	pm.pmtx.Lock()
	pm.processes[p.Id] = p
	return p, nil
}

//kill destroy process by using given factory.
func (pm *processmgr) kill(p *Process) {
    p.stop() //ignore error
	defer pm.pmtx.Unlock()
	pm.pmtx.Lock()
	delete(pm.processes, p.Id)
}

//find finds process from pid
func (pm *processmgr) find(pid proto.ProcessId) (*Process, bool) {
	defer pm.pmtx.RUnlock()
	pm.pmtx.RLock()
	p, ok := pm.processes[pid]
	return p, ok
}
